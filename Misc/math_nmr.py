import numpy as npfrom fractions import Fractionimport syssys.path.insert(1, '../Misc')sys.path.insert(2, '../Quantum')import constants as cstfrom Utils import exceptionsimport SpinOperatorsclass math_nmr:    """    A class containing mathematical definitions        ...        Attributes    ----------        Methods    -------    scalar_product(A=SpinOp, B=SpinOp)        scalar product of two operators    Hilbert_dimension(spin_system_nuclei=dict)        checks if an isotope exists    expected_norm(spin_system_nuclei=dict)        expected operator norm    get_operator_norm(OpT=SpinOperator.SpinOp)        get the norm of an operator    normalization_constant(OpT=SpinOperator.SpinOp, spin_system_nuclei=dict)        get the normalization constant to normalize an operator    """        @staticmethod    def scalar_product(A, B):        """        scalar product between two tensors            Parameters        ----------        A : TYPE: ndarray             DESCRIPTION: tensor.        B : TYPE: ndarray            DESCRIPTION: tensor.            Raises        ------        SyntaxError            DESCRIPTION: raised if A and B have different shapes.            Returns        -------        scalar_product : TYPE: ndarray            DESCRIPTION: scalar product calculated as the product of the conjugate            transpose of A with B.            """                exceptions.type_check(A, np.ndarray)        exceptions.type_check(B, np.ndarray)                if np.shape(A) != np.shape(B):            raise SyntaxError('Operators must have same dimensions.')            a_dag = np.conj(A).T        scalar_product = a_dag @ B                return scalar_product            @staticmethod    def commutator(A, B):        """        commutator between two operators        Parameters        ----------        A : TYPE: SpinOperators.SpinOp            DESCRIPTION: spin operator.        B : TYPE: SpinOperators.SpinOp            DESCRIPTION: spin operator.        Raises        ------        SyntaxError            DESCRIPTION: raised if the spin operators have different dimensions.        Returns        -------        commutator : TYPE: SpinOperators.SpinOp            DESCRIPTION: spin operator corresponding to the commutator.        """        exceptions.type_check(A, SpinOperators.SpinOp)        exceptions.type_check(B, SpinOperators.SpinOp)                if np.shape(A.OpT) != np.shape(B.OpT):            raise SyntaxError('Operators must have same dimensions.')                    commutator = A @ B - B @ A                return commutator                @staticmethod    def Hilbert_dimension(spin_system_nuclei):        """        Hilbert space dimension, given by the product of (2S+1), S spin quantum number            Parameters        ----------        spin_system_nuclei : TYPE: dictionnary            DESCRIPTION: nuclei and their associated isotope type.            Returns        -------        dim: TYPE: int            DESCRIPTION: dimension of the Hilbert space.            """                exceptions.type_check(spin_system_nuclei, dict)        exceptions.isotope_check(list(spin_system_nuclei.values()))                        dim = 1        for isotope in spin_system_nuclei.values():            S = cst.spin_quantum_number[isotope]                        dim *= 2*float(Fraction(S)) + 1         dim = int(dim)                return dim            @staticmethod    def expected_norm(spin_system_nuclei):        """        computes the expected norm            Parameters        ----------        spin_system_nuclei : TYPE: dictionnary            DESCRIPTION: nuclei and their associated isotope type.            Returns        -------        ExpectedNorm: TYPE: float            DESCRIPTION: expected norm, calculated as:                SQRT{2^(n1/2 - 2) x 2^n1}, n1/2 nbr of spin-1/2, n1 nbr of spin-1.            """                exceptions.type_check(spin_system_nuclei, dict)        exceptions.isotope_check(list(spin_system_nuclei.values()))                    n_half, n_one = 0, 0        for isotope in spin_system_nuclei.values():            if cst.spin_quantum_number[isotope] == '1/2':                n_half += 1            elif cst.spin_quantum_number[isotope] == '1':                n_one += 1                        expected_norm = np.sqrt(2**(n_half - 2) * 2**(n_one))        return expected_norm            @staticmethod    def get_operator_norm(OpT):        """        computes the current norm of an operator            Parameters        ----------        OpT : TYPE: ndarray            DESCRIPTION: spin operator.            Returns        -------        current_norm : TYPE: float            DESCRIPTION: norm of OpT.            """                scal_prod = math_nmr.scalar_product(OpT, OpT)        trace = np.trace(scal_prod)        current_norm = np.sqrt(trace)                return current_norm        @staticmethod    def normalization_constant(OpT, spin_system_nuclei = None):        """        computes the normalization constant for an operator        Parameters        ----------        OpT : TYPE: array or SpinOp            DESCRIPTION: spin operator.        spin_system_nuclei : TYPE: dictionnary, optional            DESCRIPTION: nuclei and isotope. The default is None.        Raises        ------        SyntaxError            DESCRIPTION: raised if OpT is an array and spin_system_nuclei is None.        TypeError            DESCRIPTION: raised if OpT is not an array or SpinOp.        Returns        -------        norm_constant : TYPE: float            DESCRIPTION: normalization constant.        """                if isinstance(OpT, np.ndarray):            if spin_system_nuclei == None:                raise SyntaxError('Must provide a nuclei list.')                        target_norm = math_nmr.expected_norm(spin_system_nuclei)            current_norm = math_nmr.get_operator_norm(OpT)                    elif isinstance(OpT, SpinOperators.SpinOp):            target_norm = math_nmr.expected_norm(OpT.nuclei)            current_norm = OpT.get_operator_norm()                    else:            raise TypeError('Operator must be a numpy array or a SpinOp')                norm_constant = target_norm / current_norm                return norm_constant