###This modules deals with spin tensors operators# Definition of Spin operators with normalization function, coherence order function# Definition of basis operators### import sysimport numpy as npfrom fractions import Fractionimport itertoolssys.path.insert(1, '../NMR')import constants as cst#####################################################                                                  ##                      Checks                      ##                                                  ######################################################check if input label is in the spin systemdef CheckDefinedLabel(SpinSystem, Label):    if Label not in SpinSystem.keys():        print('Please enter a label as defined in the spin system: ', str(list(SpinSystem.keys()))[1:-1])        print()        return False    else:        return True####################################################                                                 ##                      Maths                      ##                                                 #####################################################Space dimensiondef HilbertDimension(SpinSystem):        Dim = 1    for Label in SpinSystem.Nuclei.keys():        S = cst.SpinQuantumNumber(SpinSystem, Label)                Dim *= 2*float(Fraction(S)) + 1             return int(Dim)#Scalar product between operatorsdef ScalarProduct(A, B):    a = A.copy()    b = B.copy()    a = np.asarray(a)    b = np.asarray(b)            #check dimensions    if np.shape(a) != np.shape(b):        print("Dimensions of the two operators doesn't match")        print()        return None        #compute    a_dag = np.conj(a).T        if len(np.shape(a_dag)) > 0:    #A and B are tensors        return a_dag @ b    else:                           #A and B are scalars        return a_dag * b#Normalizationdef NormalizationConstant(SpinSystem, Op):    try:        n_2 = 0        n_1 = 0                for Label in SpinSystem.Nuclei.keys():            if cst.SpinQuantumNumber(SpinSystem, Label) == '1/2':                n_2 += 1            elif cst.SpinQuantumNumber(SpinSystem, Label) == '1':                n_1 += 1                        ExpectedNorm = np.sqrt(2**(n_2 - 2) * 2**(n_1))               #The expected norm is given by SQRT{2^(n1/2 - 2) x 2^n1}, n1/2 nbr of spin-1/2, n1 nbr of spin-1                #Calculate current norm        scalProd = ScalarProduct(Op, Op)        Trace = np.trace(scalProd)        Norm = np.sqrt(Trace)                return ExpectedNorm/Norm            except:        print(f'The operator {Op} cannot be normalized. Please report to us.')        print()def NormalizeOperator(SpinSystem, Op):            NormConstant = NormalizationConstant(SpinSystem, Op)        return Op * NormConstant#commutatordef Commutator(Op1, Op2):    try:        Dcomm = Op1 @ Op2 - Op2 @ Op1                return Dcomm        except:        print('Error while calculating double commutator. Please report to us.')        print()                #Project an operator on a Basis. Returns a dictionnarydef BasisProjection(Basis, Operator_in):        Operator = np.asarray(Operator_in)    Labels = list(Basis.keys())        try:        #check dimensions        dim_Op = np.shape(Operator)        dim_E = np.shape(Basis[Labels[0]])                if dim_Op != dim_E:            print("Dimension of the operator doesn't match the operator basis dimension.")            print()            return None        #Project        Decomposition = dict()        for (Label, ket_n) in Basis.items():            scalProd = ScalarProduct(ket_n, Operator)            Trace = np.trace(scalProd)                        Decomposition[Label] = Trace                    return Decomposition        except:        print('An unknown error occured. Please report to us.')        print()        return None                                    #####################################################                                                  ##                      States                      ##                                                  ######################################################States (ket and bra)def Ket(SpinSystem, States):        if len(States) != len(SpinSystem.Nuclei):        print("The number of provided states doesn't match the number of nuclei in the spin system.")        print()        return None    else:        PossibleStates = dict()        PossibleStates['1/2'] = ['a', 'b']        PossibleStates['1'] = ['m', '0', 'p']            ket = 1            try:                for c, Label in enumerate(SpinSystem.Nuclei.keys()):                SQN = cst.SpinQuantumNumber(SpinSystem, Label)                Dim = int(2.*float(Fraction(SQN)) + 1.)                                ket_c = np.zeros(Dim)                                ket_c[PossibleStates[SQN][States[c]]] = 1                                ket = np.kron(ket, ket_c)                            return ket                except KeyError:            print('Please define the states as:')            print(" - 'a' or 'b' for spin-1/2")            print(" - 'm', '0' or 'p' for spin-1")            print()                        def Bra(SpinSystem, States):        ket = Ket(SpinSystem, States)    bra = np.conj(ket).T        return bra                ########################################################                                                     ##                      Operators                      ##                                                     ########################################################    #Coherence order of spin transitionsdef CoherenceOrder(SpinSystem, Operator):        Coherences = np.zeros(len(SpinSystem.Nuclei))   #we compute coherence order for individual spin transitions        #prepare the ket to compute transitions: default is all states in their lower level    States = []    for Label in SpinSystem.Nuclei.keys():        if cst.SpinQuantumNumber(SpinSystem, Label) == '1/2':            States.append('a')        elif cst.SpinQuantumNumber(SpinSystem, Label) == '1':            States.append('m')                PossibleStates = dict()    PossibleStates['1/2'] = ['a', 'b']    PossibleStates['1'] = ['m', '0', 'p']        for c, Label in enumerate(SpinSystem.Nuclei.keys()):    #loop to compute coherence order for indivual spin transitions            SQN = cst.SpinQuantumNumber(SpinSystem, Label)        Dim = int(2.*float(Fraction(SQN)) + 1.)            #the following creates bras to check the state after applying {Operator}        ProbingStates = []        for state in range(Dim):            States_bra = States.copy()            States_bra[c] = PossibleStates[SQN][state]            bra = Bra(SpinSystem, States_bra)            ProbingStates.append(bra)                CO_state = []        for state in range(Dim):            #initial state            States_init = States.copy()            States_init[c] = PossibleStates[SQN][state]            ket_init = Ket(SpinSystem, States_init)                        #state after applying operator            ket_post = Operator @ ket_init                        #determine what is the final state and the associated coherence order of the transition if present            CO = None            for i in range(Dim):                                ScalProd_check = ProbingStates[i] @ ket_post                if np.real(ScalProd_check) != 0:    #if condition is fulfilled, the state {i} is populated after applying {Operator}                    CO = state - i                    CO_state.append(CO)                            if len(CO_state) != 0:                  #condition associated to the fact {Operator} acts on {Label}            CO_red = [min(CO_state), max(CO_state)]            if abs(CO_red[0]) == abs(CO_red[1]) and CO_red[0] != CO_red[1]:                print(f'The operator acting on {Label} contains a mixture of {CO_red[0]} and {CO_red[1]} coherences. The returned value is {CO_red[0]}.')                Coherences[c] = CO_red[0]            else:                if abs(CO_red[0]) > abs(CO_red[1]):                    Coherences[c] = CO_red[0]                else:                    Coherences[c] = CO_red[1]                Coherence_Op = sum(C for C in Coherences)        return int(Coherence_Op)                                                            #define spin tensors. Operators are not normalized by default.def SpinOp(SpinSystem, Type, Label_in = None, Normalize = True):      #SpinSystem is a class object    if Label_in == None:        if Type != 'E':            print('Please indicate a nuclei in the spin system')            print()            return None    if Type == 'E':        Dimension = HilbertDimension(SpinSystem)                        OpT = np.diag(np.ones(Dimension))                if Normalize:            return NormalizeOperator(SpinSystem, OpT)        else:            return OpT            if CheckDefinedLabel(SpinSystem.Nuclei, Label_in):        try:            Atoms = list(SpinSystem.Nuclei) #list of the atoms            PositionLabel = Atoms.index(Label_in)                        DimPrior = 1            DimPost = 1            for c, Label in enumerate(SpinSystem.Nuclei.keys()):                S = cst.SpinQuantumNumber(SpinSystem, Label)                                if c == PositionLabel:                    pass                elif c < PositionLabel:                    DimPrior *= 2*float(Fraction(S)) + 1                elif c > PositionLabel:                    DimPost *= 2*float(Fraction(S)) + 1                                                IdPrior = np.diag(np.ones(int(DimPrior)))            IdPost = np.diag(np.ones(int(DimPost)))                            S_spin = cst.SpinQuantumNumber(SpinSystem, Label_in)            operatorType = 'opI' + Type + '_' + str(int(2*float(Fraction(S_spin)) + 1))                        OpI = cst.OpDict[S_spin][operatorType]                            OpT = np.kron(np.kron(IdPrior, OpI), IdPost)                        if Normalize:                return NormalizeOperator(SpinSystem, OpT)            else:                return OpT                    except KeyError:            print(f'Operator {Type} cannot be defined for nuclei {Label}.')            print()                              ####################################################                                                 ##                      Basis                      ##                                                 #####################################################Master function for basis definitiondef DefineBasis(SpinSystem, OperatorTypes):        Basis = dict()        IndivOperators = []    for c, Label in enumerate(SpinSystem.Nuclei.keys()):        IndivOperators.append([Label + OpType for OpType in OperatorTypes[c]])    IndivOperators = IndivOperators[::-1]        AllOperators = list(itertools.product(*IndivOperators))    AllOperators = [p[::-1] for p in AllOperators]        for Op in AllOperators:        OperatorLabel = ''        Operator = np.diag(np.ones(HilbertDimension(SpinSystem)))   #Identity Operator        for c, Label in enumerate(SpinSystem.Nuclei.keys()):                        if 'E' in Op[c]:                pass            if 'e' in Op[c]:                pass            else:                OperatorLabel += Op[c]                Operator = Operator @ SpinOp(SpinSystem, Op[c][-1], Label)                    if OperatorLabel == '':            if '+' in Op:                OperatorLabel = 'e'            else:                OperatorLabel = 'E'                Basis[OperatorLabel] = NormalizeOperator(SpinSystem, Operator)            return Basis                    #Defines the Cartesian operator basisdef CartesianOperatorBasis(SpinSystem):        IndivOperators = [['E', 'x', 'y', 'z'] for l in SpinSystem.Nuclei.keys()]    Basis = DefineBasis(SpinSystem, IndivOperators)            return Basis    #Defines the shift operator basisdef ShiftOperatorBasis(SpinSystem):        IndivOperators = [['E', '0', '+', '-'] for l in SpinSystem.Nuclei.keys()]    Basis = DefineBasis(SpinSystem, IndivOperators)            return Basis#Defines the Zeeman basisdef ZeemanBasis(SpinSystem):            IndivOperators = []    for Label in SpinSystem.Nuclei.keys():        if cst.SpinQuantumNumber(SpinSystem, Label) == '1/2':            IndivOperators.append(['a', 'b'])                elif cst.SpinQuantumNumber(SpinSystem, Label) == '1':            IndivOperators.append(['m', '0', 'p'])    Basis = DefineBasis(SpinSystem, IndivOperators)            return Basis    #Defines the singlet-Triplet basis for 2 spin-1/2 spin systemsdef SingletTripletBasis(SpinSystem):        #check spin system contains only 2 nuclei    if len(SpinSystem.Nuclei) != 2:        print('The spin system must consist of 2 spins-1/2 to define the Singlet-Triplet basis')        print()        return None        #check spin system consists only of spin-1/2 nuclei    for Label in SpinSystem.Nuclei.keys():        if cst.SpinQuantumNumber(SpinSystem, Label) != '1/2':            print('The spin system must consist of 2 spins-1/2 to define the Singlet-Triplet basis')            print()            return None            #Define the basis    Basis = dict()        Atoms = list(SpinSystem.Nuclei.keys())    opS0 = SpinOp(SpinSystem, 'a', Atoms[0]) @ SpinOp(SpinSystem, 'b', Atoms[1]) - SpinOp(SpinSystem, 'b', Atoms[0]) @ SpinOp(SpinSystem, 'a', Atoms[1])    opTm1 = SpinOp(SpinSystem, 'a', Atoms[0]) @ SpinOp(SpinSystem, 'a', Atoms[1])    opTp1 = SpinOp(SpinSystem, 'b', Atoms[0]) @ SpinOp(SpinSystem, 'b', Atoms[1])    opT0 = SpinOp(SpinSystem, 'a', Atoms[0]) @ SpinOp(SpinSystem, 'b', Atoms[1]) + SpinOp(SpinSystem, 'b', Atoms[0]) @ SpinOp(SpinSystem, 'a', Atoms[1])        Basis['T-1'] = NormalizeOperator(SpinSystem, opTm1)    Basis['T0'] = NormalizeOperator(SpinSystem, opT0)    Basis['T+1'] = NormalizeOperator(SpinSystem, opTp1)    Basis['S0'] = NormalizeOperator(SpinSystem, opS0)        return Basis    def CheckBasis(SpinSystem, OperatorSet_in):    OperatorSet = OperatorSet_in.copy()        print('Checking basis...')        #Check there are no repeated operators    Repeat = False    for c, Op in enumerate(OperatorSet_in.values()):        for c2, (Label, Op2) in enumerate(OperatorSet_in.items()):            if c2 <= c:                pass            else:                comparison = Op == Op2                if comparison.all():                    print(f' The operator set contains identical elements. The operator {Label} is being removed before further checks.')                    Repeat = True                                        del OperatorSet[Label]    if not Repeat:        print(' No identical operator detected')        # check size    Dim = HilbertDimension(SpinSystem)        if len(OperatorSet) == int(4**(len(SpinSystem.Nuclei))):        BasisType = 'Liouville'        else:        if len(OperatorSet) == Dim:            BasisType = 'Hilbert'                else:            print("The number of element in the set of operators doesn't match any requirement.")            print()            return False            print(f' Size corresponds to a {BasisType} space')                    #Check identity operator is present in the Liouville set    if BasisType == 'Liouville':        if 'E' in OperatorSet.keys():            print(' Identity operator detected')        if 'e' in OperatorSet.keys():            print(' Identity operator detected')        else:            print("The identity operator must be present in the Liouville space.")            print()            return False                    #Check Normalization    n_2 = 0    n_1 = 0            for Label in SpinSystem.Nuclei.keys():        if cst.SpinQuantumNumber(SpinSystem, Label) == '1/2':            n_2 += 1        elif cst.SpinQuantumNumber(SpinSystem, Label) == '1':            n_1 += 1    ExpectedNorm = np.sqrt(2**(n_2 - 2) * 2**(n_1))               #The expected norm is given by SQRT{2^(n1/2 - 2) x 2^n1}, n1/2 nbr of spin-1/2, n1 nbr of spin-1        NeedReNorm = False    for Label, Op in OperatorSet.items():        #Calculate current norm        scalProd = ScalarProduct(Op, Op)        Trace = np.trace(scalProd)        Norm = np.sqrt(Trace)                if Norm == ExpectedNorm:            pass        else:            NeedReNorm = True            break            if not NeedReNorm:        print(' Operators are correctly normalized')    else:        print(f' Renormalizing operators to {ExpectedNorm}')                for Label in OperatorSet.keys():            OperatorSet[Label] = NormalizeOperator(SpinSystem, OperatorSet[Label])                    print('  Renormalization: DONE')                        #Check standard basis sets correctly project on OperatorSet    print(' Checking the proposed basis forms a complete set...')    if BasisType == 'Liouville':                CheckBasis = CartesianOperatorBasis(SpinSystem)            elif BasisType == 'Hilbert':                CheckBasis = ZeemanBasis(SpinSystem)                    try:        for Op in OperatorSet.values():            Decomp = BasisProjection(CheckBasis, Op)                        Norm2 = 0            for ScalProd in Decomp.values():                Norm2 += np.real(ScalProd)**2 + np.imag(ScalProd)**2            Norm = np.sqrt(Norm2)                        if Norm == 1:                pass            else:                                print("The operator set doesn't form a complete basis set.")                print()                return False                    for Op in CheckBasis.values():            Decomp = BasisProjection(OperatorSet, Op)                        Norm2 = 0            for ScalProd in Decomp.values():                Norm2 += np.real(ScalProd)**2 + np.imag(ScalProd)**2            Norm = np.sqrt(Norm2)                        if Norm == 1:                pass            else:                                print("The operator set doesn't form a complete basis set.")                print()                return False                                                print(' The operator set forms a complete basis set')        return OperatorSet            except:        print('An unknown error occured. Please report to us.')        print()        return False                    