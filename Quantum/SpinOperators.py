import numpy as npimport numpyfrom fractions import Fractionfrom itertools import takewhile, dropwhileimport sysimport itertoolssys.path.insert(1, '../NMR')sys.path.insert(2, '../Misc')import constants as cstimport math_nmrfrom Utils import exceptionsfrom Utils import overloaddef get_coherence_transition(ket, bra):    """    computes the coherence order of a transition between two states    Parameters    ----------    ket : TYPE: str        DESCRIPTION: initial state.    bra : TYPE: str        DESCRIPTION: final state.    Raises    ------    ValueError        DESCRIPTION: raised if the two states are not compatible.    Returns    -------    coherence : TYPE: int        DESCRIPTION: coherence order of the transition.    """        if len(ket) != len(bra):        raise ValueError('both states should have the same number of spins.')            transition_rules = {'a-a': 0, 'b-b': 0, 'a-b': -1, 'b-a': 1,                        '---': 0, '0-0': 0, '+-+': 0,                        '--+': -2, '--0': -1, '0-+': -1, '0--': 1, '+-0': 1, '+--': 2}        coherence = 0    for nuclei in range(len(ket)):        transition = bra[nuclei] + '-' + ket[nuclei]                if transition not in transition_rules.keys():            raise ValueError('ensure that both states are from the same spin system.')                coherence += transition_rules[transition]            return coherenceclass StateOp:    """    State operator class. Defines kets and bras        """        class ket:        """        Ket state operator.                ...                Parameters        ----------        spin_system_nuclei : TYPE: dict            DESCRIPTION: nuclei and isotope values.        states OR state_array: TYPE: str or numpy array            DESCRIPTION: label for each isotope state, or ket.            Use a (alpha) or b (beta) for spin-1/2.            Use -, 0 or + for spin-1.                Attributes        ----------        ket: array            spin state operator        nuclei: dict            nuclei label and isotope                    """            def __init__(self, spin_system_nuclei, states):            exceptions.type_check(spin_system_nuclei, dict)            exceptions.isotope_check(list(spin_system_nuclei.values()))                        if isinstance(states, str):                if len(spin_system_nuclei) != len(states):                    raise SyntaxError('The ket should contain a value for each nuclei of the spin system.')                                    PossibleStates = {'1/2': {'a': cst.sIa(), 'b': cst.sIb()},                                  '1': {'-': cst.sIm(), '0': cst.sI0(), '+': cst.sIp()}}                ket = 1                            for c, isotope in enumerate(spin_system_nuclei.values()):                    SQN = cst.spin_quantum_number[isotope]                                        if states[c] in PossibleStates[SQN].keys():                        ket_c = PossibleStates[SQN][states[c]]                    else:                        raise SyntaxError('States are defined using a or b for spin-1/2, -, 0 or + for spin-1')                                        ket = np.kron(ket, ket_c)                                    self.ket = ket                self.nuclei = spin_system_nuclei                            elif isinstance(states, numpy.ndarray):                if len(np.shape(states)) != 1 or len(states) != math_nmr.math_nmr.Hilbert_dimension(spin_system_nuclei):                    raise SyntaxError(f'ket must be of shape ({math_nmr.math_nmr.Hilbert_dimension(spin_system_nuclei)},)')                                    self.ket = states                self.nuclei = spin_system_nuclei                            else:                raise TypeError('states must be of type str or numpy.ndarray.')                        class bra:        """        Bra state operator.                ...                Parameters        ----------        spin_system_nuclei : TYPE: dict            DESCRIPTION: nuclei and isotope values.        states OR state_array: TYPE: str or numpy array            DESCRIPTION: label for each isotope state, or ket.            Use a (alpha) or b (beta) for spin-1/2.            Use -, 0 or + for spin-1.                Attributes        ----------        bra: array            spin state operator        nuclei: dict            nuclei label and isotope                    Dunders        -------        __matmul__(operator=SpinOp)        __matmul__(operator=StateOp.ket)            multiplies with spin operators or ket                    """                def __init__(self, spin_system_nuclei, states):            exceptions.type_check(spin_system_nuclei, dict)            exceptions.isotope_check(list(spin_system_nuclei.values()))                        if isinstance(states, str):                if len(spin_system_nuclei) != len(states):                    raise SyntaxError('The ket should contain a value for each nuclei of the spin system.')                                    PossibleStates = {'1/2': {'a': cst.sIa(), 'b': cst.sIb()},                                  '1': {'-': cst.sIm(), '0': cst.sI0(), '+': cst.sIp()}}                ket = 1                            for c, isotope in enumerate(spin_system_nuclei.values()):                    SQN = cst.spin_quantum_number[isotope]                                        if states[c] in PossibleStates[SQN].keys():                        ket_c = PossibleStates[SQN][states[c]]                    else:                        raise SyntaxError('States are defined using a or b for spin-1/2, -, 0 or + for spin-1')                                        ket = np.kron(ket, ket_c)                                    self.bra = np.conj(ket).T                self.nuclei = spin_system_nuclei                            elif isinstance(states, numpy.ndarray):                if len(np.shape(states)) != 1 or len(states) != math_nmr.math_nmr.Hilbert_dimension(spin_system_nuclei):                    raise SyntaxError(f'bra must be of shape ({math_nmr.math_nmr.Hilbert_dimension(spin_system_nuclei)},)')                                    self.bra = states.T                self.nuclei = spin_system_nuclei                            else:                raise TypeError('states must be of type str or numpy.ndarray.')                                def __matmul__(self, operator):            """            product of two operators. Defines a new SpinOp.                Parameters            ----------            SpinOp_B : TYPE: SpinOp or StateOp.ket                DESCRIPTION: spin operator or state operator (ket).                Raises            ------            ValueError                DESCRIPTION: raised if both operators are not from the same spin system.                Returns            -------            TYPE: SpinOp, or numpy array                DESCRIPTION: scalar product.                """                if self.nuclei != operator.nuclei:                raise ValueError('Operators and bra must be for the same spin system.')                            if isinstance(operator, SpinOp):                if len(operator.OpT) != len(self.bra):                    raise ValueError('Dimensions do not match.')                return StateOp.bra(self.nuclei, operator.OpT @ self.bra)                        if isinstance(operator, StateOp.ket):                if len(operator.ket) != len(self.bra):                    raise ValueError('Dimensions do not match.')                return operator.ket @ self.bra                        raise ValueError('operator must be of type SpinOp or StateOp.ket')class SpinOp:    """    Spin operator class. Initializing either using an already defined tensor or     tensor labels.        ...        Parameters    ----------    tensor : TYPE: ndarray, optional        DESCRIPTION: tensor. If given, OpT takes the value of tensor.        The default is None.    operator_type : TYPE: str, optional        DESCRIPTION: label for the operator. Example is Ix.        The default is 'E'.    spin_system_nuclei : TYPE: dict, optional        DESCRIPTION: nuclei and isotope values. Has to be provided if tensor=None or Normalize=True        The default is None.    label : TYPE: str, optional        DESCRIPTION: nuclei associated with the spin operator. Has to be provided if tensor=None        The default is None.    Normalize : TYPE: bool, optional        DESCRIPTION: wheter operator has to be normalized or not at construction.        The default is True.        Attributes    ----------    OpT: array        spin operator    nuclei: dict        nuclei label and isotope        Methods    -------    normalize_operator()        normalizes operator    get_operator_norm()        get the oprator norm    scalar_product(SpinOp_B=SpinOp)        scalar product between two operators    conjugate()        transforms to conjugate    transpose()        transforms to transpose    commute(SpinOp_B=SpinOp)        checks if an operator commutes with OpT    coherence_order()        coherence order of OpT            Dunders    -------    __add__(SpinOp_B=SpinOp)        adds two spin operators    __sub__(SpinOp_B=SpinOp)        substracts two spin operators    __matmul__(SpinOp_B=SpinOp)        multiplies two spin operators    __matmul__(SpinOp_B=StateOp.key)        multiplies with a ket. Returns a ket    __mul__(num=float)        multiplies a spin operator with a scalar    __rmul__(mum=float)        right-multiplies a spin operator with a scalar    __repr__()        prints the spin operator            """        @overload.overload_class_module((numpy.ndarray, dict, bool,))    def __init__(self, tensor, spin_system_nuclei, Normalize):        self.OpT = tensor        self.nuclei = spin_system_nuclei                if Normalize:            for isotope in spin_system_nuclei.items():                exceptions.isotope_check(isotope)                               self.normalize_operator()            @overload.overload_class_module((str, dict,))    def __init__(self, operator_type, spin_system_nuclei):        exceptions.isotope_check(list(spin_system_nuclei.values()))                    if operator_type == 'E':            dim = math_nmr.math_nmr.Hilbert_dimension(spin_system_nuclei)                self.OpT = np.diag(np.ones(dim))            self.nuclei = spin_system_nuclei                    else:            raise ValueError('A nuclei label has to be provided.')                @overload.overload_class_module((str, dict, str, bool,))    def __init__(self, operator_type, spin_system_nuclei, label, Normalize):        exceptions.isotope_check(list(spin_system_nuclei.values()))                    if operator_type == 'E':            self.__init__(operator_type, spin_system_nuclei, Normalize)                    else:            exceptions.nuclei_is_defined(spin_system_nuclei, label)                        nuclei_prior = {k: spin_system_nuclei[k] for k in takewhile(lambda k: k != label, spin_system_nuclei.keys())}            nuclei_post = {k: spin_system_nuclei[k] for k in dropwhile(lambda k: k != label, spin_system_nuclei.keys()) if k != label}            dim_prior = math_nmr.math_nmr.Hilbert_dimension(nuclei_prior)            dim_post = math_nmr.math_nmr.Hilbert_dimension(nuclei_post)                            IdPrior = np.diag(np.ones(int(dim_prior)))            IdPost = np.diag(np.ones(int(dim_post)))                            S_spin = cst.spin_quantum_number[spin_system_nuclei[label]]            operator_type_name = 'opI' + operator_type + '_' + str(int(2*float(Fraction(S_spin)) + 1))                        OpI = cst.OpDict[S_spin][operator_type_name]                            self.OpT = np.kron(np.kron(IdPrior, OpI), IdPost)                self.nuclei = spin_system_nuclei        if Normalize:            self.normalize_operator()                            def __add__(self, SpinOp_B):        """        sum of two operators. Defines a new SpinOp.        Parameters        ----------        SpinOp_B : TYPE: SpinOp            DESCRIPTION: spin operator        Raises        ------        ValueError            DESCRIPTION: raised if both operators are not from the same spin system.        Returns        -------        TYPE: SpinOp            DESCRIPTION: sum.        """                if exceptions.type_check(SpinOp_B, SpinOp):            if self.nuclei != SpinOp_B.nuclei:                raise ValueError('Both operators must be for the same spin system.')            if np.shape(self.OpT) != np.shape(SpinOp_B.OpT):                raise ValueError('Dimensions do not match.')            return SpinOp(self.OpT + SpinOp_B.OpT, self.nuclei, False)                            def __sub__(self, SpinOp_B):        """        difference of two operators. Defines a new SpinOp.        Parameters        ----------        SpinOp_B : TYPE: SpinOp            DESCRIPTION: spin operator        Raises        ------        ValueError            DESCRIPTION: raised if both operators are not from the same spin system.        Returns        -------        TYPE: SpinOp            DESCRIPTION: difference.        """                if exceptions.type_check(SpinOp_B, SpinOp):            if self.nuclei != SpinOp_B.nuclei:                raise ValueError('Both operators must be for the same spin system.')            elif np.shape(self.OpT) != np.shape(SpinOp_B.OpT):                raise ValueError('Dimensions do not match.')            return SpinOp(self.OpT - SpinOp_B.OpT, self.nuclei, False)                    @overload.overload_class_module((str('SpinOp'),))    def __matmul__(self, SpinOp_B):        """        product of two operators, or operator with a ket. Defines a new SpinOp. in the former case        Parameters        ----------        SpinOp_B : TYPE: SpinOp, or StateOp.ket            DESCRIPTION: spin operator or state operator.        Raises        ------        ValueError            DESCRIPTION: raised if both operators are not from the same spin system,            or dimensions don't match.        Returns        -------        TYPE: SpinOp or StateOp.ket            DESCRIPTION: scalar product.        """        if self.nuclei != SpinOp_B.nuclei:            raise ValueError('Both operators must be for the same spin system.')        if np.shape(self.OpT) != np.shape(SpinOp_B.OpT):            raise ValueError('Dimensions do not match.')        return SpinOp(self.OpT @ SpinOp_B.OpT, self.nuclei, False)            @overload.overload_class_module((StateOp.ket,))    def __matmul__(self, ket):        if self.nuclei != ket.nuclei:            raise ValueError('Operators and ket must be for the same spin system.')        if len(self.OpT) != len(ket.ket):            raise ValueError('Dimensions do not match.')        return StateOp.ket(self.nuclei, self.OpT @ ket.ket)                            def __mul__(self, num):        """        multiplies a scalar with an operator. Defines a new SpinOp.        Parameters        ----------        num : TYPE: int/float            DESCRIPTION: scalar.        Raises        ------        SyntaxError            DESCRIPTION: raised if num is spin operator.        TypeError            DESCRIPTION: raised if SpinOp_B is not a SpinOp.        Returns        -------        TYPE: SpinOp            DESCRIPTION: multiplication result.        """        if isinstance(num, (int, float)):            return SpinOp(num * self.OpT, self.nuclei, False)        if isinstance(num, SpinOp):            raise SyntaxError('Use @ when multiplying spin operators.')        raise TypeError(f'Can not multiply objects of type SpinOp and {type(num)}')                            def __rmul__(self, num):        """        multiplies a scalar with an operator. Defines a new SpinOp.        Parameters        ----------        num : TYPE: int/float            DESCRIPTION: scalar.        Returns        -------        TYPE: SpinOp            DESCRIPTION: multiplication result.        """        return self.__mul__(num)                        def __repr__(self):        """        print function        Returns        -------        str            DESCRIPTION: the tensor is str format.        """                return f'{self.OpT}'                        def normalize_operator(self):        """        Normalizes operator        Returns        -------        None.        """                    norm_constant = math_nmr.math_nmr.normalization_constant(self)                self.OpT = norm_constant * self.OpT                    def get_operator_norm(self):        """        get the norm of an operator        Returns        -------        current_norm : TYPE: float            DESCRIPTION: norm of OpT.        """                scal_prod = math_nmr.math_nmr.scalar_product(self.OpT, self.OpT)        trace = np.trace(scal_prod)        current_norm = np.sqrt(trace)                return current_norm                    def scalar_product(self, SpinOp_B):        """        scalar product between two spin operators        Parameters        ----------        SpinOp_B : TYPE: SpinOp            DESCRIPTION: spin operator.        Raises        ------        SyntaxError            DESCRIPTION: raised if the two operators do not belong to the same spin system, or do not have same dimension.        Returns        -------        scalar_product : TYPE: ndarray            DESCRIPTION: scalar product defined as conj(A).T @ B.        """                exceptions.type_check(SpinOp_B, SpinOp)                if self.nuclei != SpinOp_B.nuclei:            raise SyntaxError('Can only perform scalar product for spin operator of a single spin system.')        if np.shape(self.OpT) != np.shape(SpinOp_B.OpT):            raise SyntaxError('Operators must have same dimensions.')                    a_dag = np.conj(self.OpT).T        scalar_product = a_dag @ SpinOp_B.OpT                return scalar_product                def conjugate(self):        """        conjugates the operator                Returns        -------        None.        """                self.OpT = np.conj(self.OpT)                       def transpose(self):        """        transposes the operator        Returns        -------        None.        """                self.OpT = np.transpose(self.OpT)                    def commute(self, SpinOp_B):        """        checks if OpT commutes with SpinOp_B        Parameters        ----------        SpinOp_B : TYPE: SpinOp            DESCRIPTION: spin operator.        Raises        ------        SyntaxError            DESCRIPTION: raised if SpinOp_B is not from the same spin system.        Returns        -------        bool            DESCRIPTION: true if the spin operators commute.        """                exceptions.type_check(SpinOp_B, SpinOp)                if self.nuclei != SpinOp_B.nuclei:            raise SyntaxError('Can only apply commutator to spin operators of a single spin system.')                commutator = math_nmr.math_nmr.commutator(self, SpinOp_B)        if not any(np.concatenate(commutator.OpT)):            return True        return False    def coherence_order(self):        """        The coherence order is calculated by computing the effect of OpT on each        ket of the spin system, and getting the coherence of the transition.        The coherence order is the highest (in absolute value) coherence order found.        Returns        -------        coherence_order : TYPE: int            DESCRIPTION: coherence of OpT.        """                #build the state space        basis_ket, basis_bra = {}, {}        states = []        for isotope in self.nuclei.values():            if cst.spin_quantum_number[isotope] == '1/2':                states.append(['a', 'b'])            elif cst.spin_quantum_number[isotope] == '1':                states.append(['-', '0', '+'])        all_states_list = list(itertools.product(*states))        for state in all_states_list:            ket = ''            for i in range(len(state)):                ket += state[i]            basis_ket[ket] = StateOp.ket(self.nuclei, ket)            basis_bra[ket] = StateOp.bra(self.nuclei, ket)                #compute effect of OpT on each state and coherence order        coherence_order = 0        for ket, state_ket in basis_ket.items():            state_post = self @ state_ket                        for bra, state_bra in basis_bra.items():                if np.real(state_bra @ state_post) != 0.:                    coherence_transition = get_coherence_transition(ket, bra)                    if abs(coherence_transition) > abs(coherence_order):                        coherence_order = coherence_transition                                return coherence_order