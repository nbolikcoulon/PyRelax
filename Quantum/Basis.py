import numpy as npimport constants as cstimport itertoolsimport syssys.path.insert(1, '../NMR')sys.path.insert(2, '../SpinSystem')sys.path.insert(3, '../Misc')import SpinOperatorsimport nucleiimport math_nmrfrom Utils import exceptionsclass Basis:    """    Basis class. Initializes using nuclei and either a user-defined basis (which    will be checked) or a type of basis name.        ...        Parameters    ----------    nuclei : TYPE: nuclei.nuclei class object        DESCRIPTION: nuclei associated info    basis_type : TYPE: dict, optional        DESCRIPTION: type of basis, possible values are:               CartesianOperatorBasis               ShiftOperatorBasis               ZeemanBasis               SingletTripletBasis            The default is None.    basis_set : TYPE: dict, optional        DESCRIPTION. user-input basis operator set. The default is None.    update : TYPE: bool, optional        DESCRIPTION: relevant only if basis_set is not None. Set to True if         basis_set can be updated if necessary (see check_basis).        The default is False.        Attributes    ----------    basis_type: str        type of basis among CartesianOperatorBasis, ShiftOperatorBasis, ZeemanBasis, SingletTripletBasis    basis: dictionnary        basis operators    __nuclei: dictionnary        nuclei and isotopes        Methods    -------    define_basis(basis_type=str)        defines a basis. Accepts:            CartesianOperatorBasis            ShiftOperatorBasis            ZeemanBasis            SingletTripletBasis    check_basis(basis_set=dict, update=bool)        check if a set of operator forms a basis    basis_projection(OpT=SpinOperators.SpinOp)        projection of an operator on the basis            Dunders    -------    __repr__()        prints operator basis label    """        def __init__(self, nuclei_in, basis_type = None, basis_set = None, update = False):        exceptions.type_check(nuclei_in, dict)                if isinstance(list(nuclei_in.values())[0], nuclei.nuclei):            for v in nuclei_in.values():                exceptions.type_check(v, nuclei.nuclei)            self.__nuclei = {k:v.isotope for k,v in nuclei_in.items()}        elif isinstance(list(nuclei_in.values())[0], str):            exceptions.isotope_check(list(nuclei_in.values()))            self.__nuclei = nuclei_in                    self.basis_type = None        self.basis = None            if isinstance(basis_set, dict):            self.basis = self.check_basis(basis_set, update)            self.basis_type = 'custom'        else:            if basis_type != None:                self.define_basis(basis_type)            else:                self.define_basis('CartesianOperatorBasis')                                            def __repr__(self):        """        prints the basis operator labels                Returns        -------        None.        """                L = int(len(self.basis) / 3.)        print('Basis operator list:')        for i in range(L):            k1 = list(self.basis.keys())[int(3*i)]            k2 = list(self.basis.keys())[int(3*i+1)]            k3 = list(self.basis.keys())[int(3*i+2)]            print(f'{self.basis[k1]}\t{self.basis[k2]}\t{self.basis[k3]}')        if 3*L == len(self.basis) - 2:            k1 = list(self.basis.keys())[-2]            k2 = list(self.basis.keys())[-1]            print(f'{self.basis[k1]}\t{self.basis[k2]}')        else:            k1 = list(self.basis.keys())[-1]            print(f'{self.basis[k1]}')            def define_basis(self, basis_type):        """        defines the basis.        Parameters        ----------        basis_type : TYPE: str            DESCRIPTION: type of basis. Options amond:\                CartesianOperatorBasis                ShiftOperatorBasis                ZeemanBasis                SingletTripletBasis.        Raises        ------        TypeError            DESCRIPTION: raised if SingletTripletBasis and the spin system is not            a 2 spin-hald spin system.        Returns        -------        None.        """                exceptions.member_of_list_check(basis_type,                             ['CartesianOperatorBasis', 'ShiftOperatorBasis', 'ZeemanBasis', 'SingletTripletBasis'])                Basis = dict()                if basis_type == 'SingletTripletBasis':            if len(self.__nuclei) != 2:                raise TypeError('SingletTripletBasis can only be set of 2 spin-1/2 systems')            for isotope in self.__nuclei.value():                if cst.spin_quantum_number(isotope) != '1/2':                    raise TypeError('SingletTripletBasis can only be set of 2 spin-1/2 systems')                            atoms = list(self.__nuclei.keys())            Ia = SpinOperators.SpinOp('a', self.__nuclei, atoms[0])            Ib = SpinOperators.SpinOp('b', self.__nuclei, atoms[0])            Sa = SpinOperators.SpinOp('a', self.__nuclei, atoms[1])            Sb = SpinOperators.SpinOp('b', self.__nuclei, atoms[1])                        opS0  = Ia @ Sb - Ib @ Sa            opTm1 = Ia @ Sa            opTp1 = Ib @ Sb            opT0  = Ia @ Sb + Ib @ Sa                        Basis['T-1'] = opTm1.normalize_operator()            Basis['T0']  = opT0.normalize_operator()            Basis['T+1'] = opTp1.normalize_operator()            Basis['S0']  = opS0.normalize_operator()                    else:            if basis_type == 'CartesianOperatorBasis':                operator_types = [['E', 'x', 'y', 'z'] for l in self.__nuclei.keys()]            elif basis_type == 'ShiftOperatorBasis':                operator_types = [['e', '0', '+', '-'] for l in self.__nuclei.keys()]            elif basis_type == 'ZeemanBasis':                operator_types = []                for isotope in self.__nuclei.values():                    if cst.spin_quantum_number[isotope] == '1/2':                        operator_types.append(['a', 'b'])                    elif cst.spin_quantum_number[isotope] == '1':                        operator_types.append(['m', '0', 'p'])                    individual_operators = []            for c, label in enumerate(self.__nuclei.keys()):                individual_operators.append([label + OpType for OpType in operator_types[c]])            all_operators = list(itertools.product(*individual_operators))                        for Op in all_operators:                operator_label = ''                operator = SpinOperators.SpinOp('E', self.__nuclei)                                for c, label in enumerate(self.__nuclei.keys()):                    if 'E' not in Op[c] and 'e' not in Op[c]:                        operator_label += Op[c]                        operator = operator @ SpinOperators.SpinOp(Op[c][-1], self.__nuclei, label, False)                                        if operator_label == '':                    if '+' in Op:                        operator_label = 'e'                    else:                        operator_label = 'E'                                operator.normalize_operator()                Basis[operator_label] = operator                    self.basis_type = basis_type        self.basis = Basis        def check_basis(self, basis_set, update = False):        """        checks a basis (shape of operators, norm, dimension, complete basis set).        Parameters        ----------        basis_set : TYPE: dict            DESCRIPTION: input basis set.        update : TYPE: bool, optional            DESCRIPTION: whether the basis can be updated or not (only for duplicate            elements or normalization).            The default is False.        Raises        ------        SyntaxError            DESCRIPTION: raised if the basis_set is not a proper basis.        Returns        -------        basis_set_cp : TYPE: dict            DESCRIPTION: potentially updated basis set.        """                for OpT in basis_set.values():            exceptions.type_check(OpT, SpinOperators.SpinOp)            if OpT.nuclei != list(basis_set.values())[0].nuclei:                raise SyntaxError('Operators must belong to the same spin system.')                    basis_set_cp = basis_set.copy()                for c, Op in enumerate(np.asarray(list(basis_set.values()))[:-1]):            for c2, Op2 in enumerate(np.asarray(list(basis_set.values()))[c+1:]):                if (Op.OpT == Op2.OpT).all():                    if not update:                        raise SyntaxError('The operator set contains identical elements. Use update=True to remove them.')                    label = list(basis_set.keys())[c2]                    del basis_set_cp[label]                if len(basis_set_cp) == int(4**(len(self.__nuclei))):            BasisSpace = 'Liouville'        elif len(basis_set_cp) == math_nmr.math_nmr.Hilbert_dimension(self.__nuclei):            BasisSpace = 'Hilbert'        else:            raise SyntaxError('The number of element in the set of operators does not match any requirement for a basis set')        print(f'Size corresponds to a {BasisSpace} space')                    if BasisSpace == 'Liouville':            if 'E' not in basis_set_cp.keys() and 'e' not in basis_set_cp.keys():                raise SyntaxError('The identity operator must be present in a Liouville space.')                    expected_norm = math_nmr.math_nmr.expected_norm(self.__nuclei)        for label, Op in basis_set_cp.items():            Norm = Op.get_operator_norm()                        if Norm != expected_norm:                if not update:                    raise SyntaxError('Operators need to be normalized. Use update=True to normalize them.')                Op.normalize_operator()                basis_set_cp[label] = Op                    if BasisSpace == 'Liouville':            Check_Basis = Basis(self.__nuclei, basis_type = 'CartesianOperatorBasis')        elif BasisSpace == 'Hilbert':            Check_Basis = Basis(self.__nuclei, basis_type = 'ZeemanBasis')                            for Op in basis_set_cp.values():            decomposition = Check_Basis.basis_projection(Op)            Norm = np.sqrt( sum(np.real(proj)**2 + np.imag(proj)**2 for proj in decomposition.values()) )                        if Norm != 1.0:                raise SyntaxError('The operator set does not form a complete basis set.')                    for Op in Check_Basis.basis:            decomposition = dict()            for (label, op) in basis_set_cp.items():                scalProd = op.scalar_product(OpT)                trace = np.trace(scalProd)                decomposition[label] = trace                            Norm = np.sqrt( sum(np.real(proj)**2 + np.imag(proj)**2 for proj in decomposition.values()) )                        if Norm != 1.0:                raise SyntaxError('The operator set does not form a complete basis set.')                                  print(' The operator set forms a complete basis set')        return basis_set_cp                    def basis_projection(self, OpT):        """        projection of an operator on the basis        Parameters        ----------        OpT : TYPE: SpinOp            DESCRIPTION: spin operator.        Returns        -------        decomposition : TYPE: dict            DESCRIPTION: decomposition on the basis set.        """                decomposition = dict()        for (label, op) in self.basis.items():            scalProd = op.scalar_product(OpT)            trace = np.trace(scalProd)            decomposition[label] = trace                    return decomposition